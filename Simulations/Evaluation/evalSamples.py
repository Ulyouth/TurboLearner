#!/usr/bin/env python
"""
NAME:   evalSamples.py
AUTHOR: Ulyouth
DATE:   12.06.2020 
DESC:   A script to evaluate which Myong-Kasagi model coefficients best match
        the sCO2 DNS data. The script uses the samples generated by the 
        script 'genSamples.sh' for the evaluation process.   

USAGE:  evalSamples.py [CASE] [CSV] [LOG] [PRT]
        Where:
        CASE is the case to be evaluated.
        CSV  is a .csv file containing the script's parameters. Syntax below.
        LOG  is to toogle log activation. [0=off; 1=on]
        PRT  is to display messages. [0=off; 1=on] 
        
        The syntax of the CSV file is:
            [case  smpl_path  dns_path  tau_w0  qw max_dr  max_dT  x]
        Where:
        case       is the case sampled. (e.g. 42F)
        smpl_path  is the sample path. (e.g. /Samples/_42F_2_4_Prt=0.85_Astar)
        dns_path   is the DNS path. (e.g. /Samples/DNS/42F)
        tau_w0     is the wall shear stress at the inlet (used in the 
                   normalization of TKE values).
        qw         is the wall heat flux of the case.
        max_dr     is the maximum variance between points to be admitted. 
        min_dT     is the minimum temperature variance to be considered.         
        x          is the list of variables sampled with their default values.
        
        Example of x:
        Astar  Cd
        70     5
"""

import sys
import os
import pandas as pd
from plotGraphs import plotCoeffErrGraph, plotRadialProfs, plotAxialProfs

#
# Open the CSV file containing the parameters.
#
case = sys.argv[1]
csv = pd.read_csv(sys.argv[2])
log = int(sys.argv[3])
prt = int(sys.argv[4])

if prt == 1: print(__doc__)

#
# Define the name of the sample folder and variables.
#
i = csv[csv['case'] == case].index.values[0]

case = csv['case'][i]
smpl_path = csv['smpl_path'][i]
dns_path = csv['dns_path'][i]
qw = float(csv['qw'][i])
tau_w0 = float(csv['tau_w0'][i])
max_dr = float(csv['max_dr'][i])
min_dT = float(csv['min_dT'][i])

#
# Create a list with the default coefficient values.
#
def_coeffs = []
coeff_list = list(csv.columns[7:])

for x in coeff_list:
    def_coeffs.append(x)
    def_coeffs.append(csv[x][0])

#
# Read the DNS data.
#
d0_path = dns_path + "/DNS_" + case + "_z=0D.csv"
d5_path = dns_path + "/DNS_" + case + "_z=5D.csv"
d15_path = dns_path + "/DNS_" + case + "_z=15D.csv"
d27_path = dns_path + "/DNS_" + case + "_z=27D.csv"
wall_path = dns_path + "/DNS_" + case + "_x.csv"

try: dns_d0 = pd.read_csv(d0_path) 
except: dns_d0 = pd.DataFrame()
try: dns_d5 = pd.read_csv(d5_path) 
except: dns_d5 = pd.DataFrame()
try: dns_d15 = pd.read_csv(d15_path) 
except: dns_d15 = pd.DataFrame()
try: dns_d27 = pd.read_csv(d27_path) 
except: dns_d27 = pd.DataFrame()
try: dns_wall = pd.read_csv(wall_path) 
except: dns_wall = pd.DataFrame()

#
# Convert the DNS TKE values to relative values.
#    
if dns_d0.empty == False: 
    dns_d0['TKE'] = dns_d0['TKE'] / tau_w0
if dns_d5.empty == False: 
    dns_d5['TKE'] = dns_d5['TKE'] / tau_w0
if dns_d15.empty == False: 
    dns_d15['TKE'] = dns_d15['TKE'] / tau_w0
if dns_d27.empty == False: 
    dns_d27['TKE'] = dns_d27['TKE'] / tau_w0

#
# Print simulation info.
#    
if prt == 1:     
    print("\nCase: " + case)
    print("Sample path: " + smpl_path)
    print("DNS path: " + dns_path)
    print("DNS samples: " + ("d0 " if dns_d0.empty == False else "") +
          ("d5 " if dns_d5.empty == False else "") +
          ("d15 " if dns_d15.empty == False else "") +
          ("d27 " if dns_d27.empty == False else "") +
          ("wall " if dns_wall.empty == False else "") +"\n")

coeffs = best_coeffs = def_coeffs[:]
best_data = []
min_err = -1
res = []

for x in sorted(os.listdir(smpl_path)):
    # Define the name of the current case folder.
    case_path = smpl_path + "/" + x
    
    # Verifiy if the current item is a folder.
    if os.path.isdir(case_path) == False:
        continue
    
    r = []
    
    #
    # Read the coefficient values from the name of the case folders.
    #
    for y in range(0, len(coeffs), 2):
        # Format the coefficient name and search it in the case folder.
        s = "_" + def_coeffs[y] + "="
        start = x.find(s)
        
        # Check if the current coefficient was sampled.
        if start == -1: 
            coeffs[y+1] = def_coeffs[y+1] 
        else:
            start += len(s)
            end = x.find("_", start)

            # Extract the coefficient value.
            s = x[start:(end if end != -1 else len(x))]
        
            coeffs[y+1] = float(s)

        r.append(coeffs[y+1])
        
        if prt == 1: print(coeffs[y] + "=" + str(coeffs[y+1]), end = "  ")

    d0 = pd.DataFrame()
    d5 = pd.DataFrame()
    d15 = pd.DataFrame()
    d27 = pd.DataFrame()
    wall = pd.DataFrame()
    
    #
    # Read the sample's data and merge them in case of multiple datasets.
    #  
    for y in sorted(os.listdir(case_path)):
        try: frame = pd.read_csv(case_path + "/" + y)
        except: continue 
        
        if y.startswith("sampleLineD0_") == True: 
            d0 = frame if d0.empty == True else pd.merge(d0, frame, on='x')
        elif y.startswith("sampleLineD5_") == True: 
            d5 = frame if d5.empty == True else pd.merge(d5, frame, on='x')
        elif y.startswith("sampleLineD15_") == True: 
            d15 = frame if d15.empty == True else pd.merge(d15, frame, on='x')
        elif y.startswith("sampleLineD27_") == True: 
            d27 = frame if d27.empty == True else pd.merge(d27, frame, on='x')
        elif y.startswith("sampleLineWall_") == True: 
            wall = frame if wall.empty == True else pd.merge(wall, frame, on='z')
    
    #
    # Format the samples' datasets.
    # 1) Invert the data rows, so the values match the DNS data.
    # 2) Convert the radii/length values to relative values, same for TKE.
    #    
    if d0.empty == False: 
        d0 = d0.iloc[::-1]
        d0.reset_index(drop=True, inplace=True)
        d0['x'] = d0['x'] / 0.001 # R=0.001m
        d0['k'] = d0['k'] * d0['rho'] / tau_w0
    if d5.empty == False: 
        d5 = d5.iloc[::-1]
        d5.reset_index(drop=True, inplace=True)
        d5['x'] = d5['x'] / 0.001 # R=0.001m
        d5['k'] = d5['k'] * d5['rho'] / tau_w0
    if d15.empty == False: 
        d15 = d15.iloc[::-1]
        d15.reset_index(drop=True, inplace=True)
        d15['x'] = d15['x'] / 0.001 # R=0.001m
        d15['k'] = d15['k'] * d15['rho'] / tau_w0     
    if d27.empty == False: 
        d27 = d27.iloc[::-1]
        d27.reset_index(drop=True, inplace=True)
        d27['x'] = d27['x'] / 0.001 # R=0.001m
        d27['k'] = d27['k'] * d27['rho'] / tau_w0
    if wall.empty == False: 
        wall['z'] = wall['z'] / 0.002 # D=0.002m
        
        # Delete all rows with negative z values.
        wall = wall[wall['z'] >= 0]
        wall.reset_index(drop=True, inplace=True)

    #
    # Compare the radial/axial temperature profiles of the sample 
    # to the DNS data.
    #
    e = 0 # Total error of comparison.
    cd0 = cd5 = cd15 = cd27 = cwall = 0 # Number of data points compared.
    td0 = td5 = td15 = td27 = twall = 0 # Maximum data point count.
    
    data = [d0, 'x', 'T', dns_d0, 'r/R', 'Tmean', 
            d5, 'x', 'T', dns_d5, 'r/R', 'Tmean', 
            d15, 'x', 'T', dns_d15, 'r/R', 'Tmean',
            d27, 'x', 'T', dns_d27, 'r/R', 'Tmean',
            wall, 'z', 'T', dns_wall, 'z/D', 'Tw']

    for y in range(0, len(data), 6):
        # Check if the DNS/sample's dataframe is empty.
        if data[y].empty == True or data[y+3].empty == True:
            continue
        
        name = data[y+1]
        prop = data[y+2]
        dnsName = data[y+4]
        dnsProp = data[y+5]
        
        for i in range(len(data[y][name])):
            min_var = -1
            z = 0
            
            if y == 0: td0 += 1
            elif y == 6: td5 += 1
            elif y == 12: td15 += 1
            elif y == 18: td27 += 1
            elif y == 24: twall += 1
            
            # It is unlikely that the points within the radial & axial 
            # DNS/sample profiles are going to be numerically the same. For
            # that reason we determine which points from the DNS/sample data 
            # have the least variance from each other and use their temperature
            # values to decide for the best coefficients.
            for j in range(len(data[y+3][dnsName])):
                smpl_var = data[y][name][i]
                dns_var = data[y+3][dnsName][j]
                delta_var = abs(smpl_var - dns_var)
                
                var = delta_var / (abs(dns_var) if dns_var != 0 else 1)
                
                if min_var == -1 or var < min_var:
                    min_var = var
                    z = j

            # Check if the points with the least variance are within the
            # predetermined tolerance range.
            if min_var <= max_dr:
                if y == 0: cd0 += 1
                elif y == 6: cd5 += 1
                elif y == 12: cd15 += 1
                elif y == 18: cd27 += 1
                elif y == 24: cwall += 1
                
                if prop in data[y].columns and dnsProp in data[y+3].columns:
                    smpl_T = data[y][prop][i]
                    dns_T = data[y+3][dnsProp][z]
                    delta_T = abs(smpl_T - dns_T)
                    
                    # Check if the temperature variance is enough to be considered.
                    if delta_T >= min_dT:
                        e += ((delta_T / dns_T) * 100)

    
    count = cd0 + cd5 + cd15 + cd27 + cwall
    
    # Skip empty samples.
    if count == 0: continue
    
    # Divide by the number comparison data points.
    e /= count
    
    # Log the results.
    r.append(e)
    res.append(r)
    
    if min_err == -1 or e < min_err:
        # Save the best results.
        min_err = e  
        best_coeffs = coeffs[:]
        best_data = data[:]

    if prt == 1: 
        print("[DPs:", end=" ")
        
        print(("d0(" + str(cd0) + "/" + str(td0) + ")") 
        if d0.empty == False else "", end=" ")

        print(("d5(" + str(cd5) + "/" + str(td5) + ")") 
        if d5.empty == False else "", end=" ")
        
        print(("d15(" + str(cd15) + "/" + str(td15) + ")") 
        if d15.empty == False else "", end=" ")
                
        print(("d27(" + str(cd27) + "/" + str(td27) + ")") 
        if d27.empty == False else "", end=" ")
        
        print(("wall(" + str(cwall) + "/" + str(twall) + ")") 
        if wall.empty == False else "", end="  ")
                       
        print("e=" + str(e) + "]")   

if prt == 1: 
    print("\n\nSimulation completed. The best coefficients are: \n") 

    for x in range(0, len(best_coeffs), 2):  
        print(best_coeffs[x] + "=" + str(best_coeffs[x+1]), end = "  ")
        
    print("[e=" + str(min_err) + "]") 

# Save the log results in a CSV file and plot the results.
if log == 1:
    coeff_list.append("Error")
    
    # Create dataframe for the sample's error profile.
    log_csv = pd.DataFrame(res, columns=coeff_list)
    
    # Organize the values of the dataframe.
    log_csv.sort_values(by=coeff_list, inplace=True)
    
    # Save the dataframe as CSV file in sample's path.
    log_csv.to_csv(smpl_path + "/log_err.csv", encoding="utf-8", index=False)

    # Plot fluid properties.
    plotCoeffErrGraph(case, def_coeffs[0], def_coeffs, log_csv, smpl_path) 
    plotRadialProfs(case, best_data, best_coeffs, 'U_2', 'UzMean', 
                    [0, 1, -0.1, 0.5], "Velocity [m/s]", smpl_path)
    plotRadialProfs(case, best_data, best_coeffs, 'T', 'Tmean', 
                    [0, 1, 260, 350], "Temperature [K]", smpl_path)
    plotAxialProfs(case, best_data, best_coeffs, 'T', 'Tw', 
                    [0, 35, 250, 350], "Wall temperature [K]", smpl_path)
    plotRadialProfs(case, best_data, best_coeffs, 'k', 'TKE', 
                    [0, 1, 0, 20], "k*ρ/τw,0 [-]", smpl_path)
    
if prt == 1: print("")
elif prt == 0: sys.exit(min_err)
